<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ITST – 5ª · Lez2_6 · Generalizzazione e specializzazione</title>
  <link rel="stylesheet" href="../style.css" />
  <link rel="stylesheet" href="../default.css" />
  <script src="../highlight.js"></script>
  <script>
    try { hljs.highlightAll(); } catch (e) {}
    function prevSlide(){ window.location.href = "lez2_5.html"; }
    function nextSlide(){ window.location.href = "lez2_7.html"; }
    function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
    function toggleBox(btnId, boxId){
      const box = document.getElementById(boxId);
      const btn = document.getElementById(btnId);
      const open = box.style.display === 'block';
      box.style.display = open ? 'none' : 'block';
      btn.textContent = open ? 'Mostra ▼' : 'Nascondi ▲';
    }
  </script>
</head>
<body>
  <!-- BEGIN MENU -->
  <button class="menu-toggle" onclick="toggleMenu()">&#9776; Menu</button>
  <div class="sidebar" id="menu">
    <h2>Lezione 2 — Diagramma E-R di Chen</h2>
    <ul>
      <li><a href="lez2_1.html">Lez2.1: Introduzione e motivazioni</a></li>
      <li><a href="lez2_2.html">Lez2.2: Concetti fondamentali</a></li>
      <li><a href="lez2_3.html">Lez2.3: Relazioni e cardinalità</a></li>
      <li><a href="lez2_4.html">Lez2.4: Entità deboli e identificazione</a></li>
      <li><a href="lez2_5.html">Lez2.5: Attributi derivati e composti</a></li>
      <li><a href="lez2_6.html">Lez2.6: Generalizzazione e specializzazione</a></li>
      <li><a href="lez2_7.html">Lez2.7: Traduzione E-R → Relazionale</a></li>
      <li><a href="lez2_8.html">Lez2.8: Esercitazione e micro-verifica</a></li>
    </ul>
  </div>
  <!-- END MENU -->

  <div class="slide">
    <h1>Generalizzazione e specializzazione</h1>

    <div class="nav-buttons" style="margin-bottom:10px">
      <button onclick="prevSlide()">&#8592; Indietro</button>
      <button onclick="nextSlide()">Avanti &#8594;</button>
    </div>

    <div class="content-box">
      <div class="inner-box">

        <h2>Definizioni</h2>
        <div class="box">
          <ul>
            <li><strong>Specializzazione</strong> (top-down): da un’entità <code>S</code> (supertipo) si definiscono sottoinsiemi <code>S₁, …, Sₖ</code> (sottotipi) con proprietà aggiuntive.</li>
            <li><strong>Generalizzazione</strong> (bottom-up): da entità affini <code>S₁, …, Sₖ</code> si astrae un supertipo comune <code>S</code> che cattura attributi/relazioni condivisi.</li>
            <li><strong>Ereditarietà</strong>: ogni sottotipo <code>Sᵢ</code> <em>eredita</em> gli attributi e le relazioni di <code>S</code> e può aggiungerne di propri.</li>
          </ul>
        </div>

        <h2>Vincoli sulla specializzazione</h2>
        <div class="box">
          <ul>
            <li><strong>Disgiunzione (D)</strong> vs <strong>Sovrapposizione (O)</strong>:
              <ul>
                <li><em>Disgiunta</em>: <code>Sᵢ ∩ Sⱼ = ∅</code> per <code>i ≠ j</code>.</li>
                <li><em>Sovrapposta</em>: è ammesso <code>Sᵢ ∩ Sⱼ ≠ ∅</code>.</li>
              </ul>
            </li>
            <li><strong>Copertura Totale (T)</strong> vs <strong>Parziale (P)</strong>:
              <ul>
                <li><em>Totale</em>: <code>S = S₁ ∪ ··· ∪ Sₖ</code> (ogni istanza di <code>S</code> appartiene almeno a un sottotipo).</li>
                <li><em>Parziale</em>: <code>S ⊇ S₁ ∪ ··· ∪ Sₖ</code> (alcune istanze di <code>S</code> non appartengono a nessun sottotipo).</li>
              </ul>
            </li>
          </ul>
        </div>

        <h2>Ereditarietà di chiavi e attributi</h2>
        <div class="box">
          <ul>
            <li><strong>Chiave</strong>: la chiave del supertipo <code>K(S)</code> è anche chiave dei sottotipi (<code>K(Sᵢ) = K(S)</code>); i sottotipi <em>non</em> introducono chiavi autonome.</li>
            <li><strong>Attributi</strong>: ogni <code>Sᵢ</code> eredita tutti gli attributi/relazioni di <code>S</code> e può aggiungere attributi propri (es. <code>Matricola</code> per <code>STUDENTE</code>).</li>
            <li><strong>Vincoli</strong>: i vincoli su <code>S</code> si applicano anche a <code>Sᵢ</code>; quelli definiti su <code>Sᵢ</code> restringono ulteriormente.</li>
          </ul>
          <div class="note">Questa semantica è coerente con la trasformazione verso il modello relazionale (regole in Lez2.7).</div>
        </div>

        <h2>Rappresentazione grafica</h2>
        <div class="box">
          <p>Usiamo una notazione Chen-like con nodo ISA (triangolo). Doppia linea dal supertipo al nodo: <strong>copertura totale</strong>. Etichette <strong>D</strong>/<strong>O</strong> per disgiunta/sovrapposta.</p>

          <svg viewBox="0 0 820 280" width="100%" height="300" preserveAspectRatio="xMidYMid meet" style="display:block;margin:0 auto">
            <!-- Supertipo PERSONA -->
            <rect x="340" y="30" width="140" height="50" rx="8" ry="8"
                  fill="#f0f9ff" stroke="#2563eb" stroke-width="2"/>
            <text x="410" y="60" font-size="15" text-anchor="middle" fill="#1e3a8a">PERSONA</text>

            <!-- Nodo ISA (triangolo) -->
            <polygon points="370,120 410,80 450,120"
                     fill="#fff7ed" stroke="#f59e0b" stroke-width="2"/>
            <text x="410" y="112" font-size="12" text-anchor="middle" fill="#78350f">ISA</text>

            <!-- Doppia linea per copertura TOTALE (PERSONA ⇒ ISA) -->
           
            <!-- Etichetta D (disjoint) accanto al nodo -->
            <text x="460" y="102" font-size="12" fill="#78350f">D.T.</text>

            <!-- Sottotipo STUDENTE -->
            <rect x="150" y="200" width="160" height="50" rx="8" ry="8"
                  fill="#f0f9ff" stroke="#2563eb" stroke-width="2"/>
            <text x="230" y="230" font-size="15" text-anchor="middle" fill="#1e3a8a">STUDENTE</text>

            <!-- Sottotipo DOCENTE -->
            <rect x="510" y="200" width="160" height="50" rx="8" ry="8"
                  fill="#f0f9ff" stroke="#2563eb" stroke-width="2"/>
            <text x="590" y="230" font-size="15" text-anchor="middle" fill="#1e3a8a">DOCENTE</text>

            <!-- Collegamenti ISA -> sottotipi -->
            <line x1="394" y1="120" x2="310" y2="200" stroke="#2563eb" stroke-width="2"/>
            <line x1="426" y1="120" x2="510" y2="200" stroke="#2563eb" stroke-width="2"/>
          </svg>

          <p class="ok">Esempio: <code>PERSONA</code> specializzata in <code>STUDENTE</code> e <code>DOCENTE</code>, <strong>disgiunta</strong> e a <strong>copertura totale</strong>.</p>

          <div style="margin-top:.6rem">
            <button id="btnVAR" onclick="toggleBox('btnVAR','ansVAR')">Mostra altre varianti ▼</button>
          </div>
          <div id="ansVAR" style="display:none; margin-top:.5rem">
            <ul>
              <li><strong>Parziale (P)</strong>: singola linea da <code>PERSONA</code> al nodo ISA (alcune persone non sono né studenti né docenti).</li>
              <li><strong>Sovrapposta (O)</strong>: etichetta “O”; è ammesso che una persona sia sia <em>studente</em> sia <em>docente</em> (insiemi che si intersecano).</li>
            </ul>
          </div>
        </div>

        <h2>Formalizzazione</h2>
        <div class="box">
          <pre><code class="language-text">Sia S l'insieme del supertipo e S1,...,Sk i sottotipi.
- Inclusione: ∀ i,  Si ⊆ S
- Disgiunta:  ∀ i≠j,  Si ∩ Sj = ∅
- Sovrapposta: ∃ i≠j, Si ∩ Sj ≠ ∅
- Totale:     S = S1 ∪ ··· ∪ Sk
- Parziale:   S ⊇ S1 ∪ ··· ∪ Sk

Ereditarietà di chiave:
- K(Si) = K(S)  (la chiave del supertipo identifica anche le istanze del sottotipo)
          </code></pre>
        </div>

<h2>Implicazioni progettuali</h2>
<div class="box">
  <ul>
    <li>
      <strong>Localizzazione delle proprietà</strong>:
      <ul>
        <li>Metti nel <em>supertipo</em> solo gli attributi/relazioni che sono <strong>veri per tutte</strong> le istanze di <code>S</code>.</li>
        <li>Se un attributo vale solo per alcuni sottoinsiemi, spostalo nel <em>sottotipo</em> corrispondente: evita campi opzionali che diventano quasi sempre NULL.</li>
        <li><em>Regola</em>: se un attributo ha vincoli diversi (dominio, obbligatorietà) tra sottoinsiemi, <strong>specializza</strong>.</li>
      </ul>
    </li>

    <li>
      <strong>Collocazione dei vincoli</strong>:
      <ul>
        <li>Vincoli generali (identità, integrità di dominio) su <code>S</code>; vincoli specifici su <code>Sᵢ</code>.</li>
        <li>Se la specializzazione è <strong>disgiunta</strong> (D), impiega un <em>predicato di appartenenza</em> per escludere sovrapposizioni:
          <code>∀x, (x ∈ Sᵢ ∧ x ∈ Sⱼ) ⇒ falso</code> per <code>i ≠ j</code>.</li>
        <li>Se è a <strong>copertura totale</strong> (T): <code>∀x ∈ S, ∃i : x ∈ Sᵢ</code> (nessuna istanza “orfana”).</li>
      </ul>
    </li>

    <li>
      <strong>Ereditarietà delle chiavi</strong>:
      <ul>
        <li>La chiave di <code>S</code>, <code>K(S)</code>, identifica anche le istanze di ogni <code>Sᵢ</code> (niente nuove chiavi autonome nei sottotipi).</li>
        <li>Evita “pseudo-chiavi” nei sottotipi: se serve distinguere varianti, usa attributi descrittivi o ulteriori specializzazioni.</li>
      </ul>
    </li>

    <li>
      <strong>Chiarezza semantica vs optionalite</strong>:
      <ul>
        <li>Un unico tipo con molti campi opzionali tende a nascondere regole e a generare incoerenze.</li>
        <li>La specializzazione rende <strong>esplicite</strong> appartenenze, obbligatorietà e domini diversi tra sottoinsiemi.</li>
      </ul>
    </li>
</div>
<h2>Impatto sulla traduzione (preview Lez2.7)</h2>
<div class="box">
       <ul>
        <li>La scelta D/O e T/P influenza la <em>strategia</em> di traduzione (tabella unica, per gerarchia, per sottotipo) e l’enforcement dei vincoli.</li>
        <li>Con D+T è più semplice garantire integrità e query senza ambiguità; con O o P serviranno vincoli aggiuntivi.</li>
      </ul>
      <div class="note">Le regole operative di trasformazione sono dettagliate nella Lez2.7.</div>
  

  <div style="margin-top:.6rem">
    <button id="btnCHK26" onclick="toggleBox('btnCHK26','ansCHK26')">Checklist decisionale rapida ▼</button>
  </div>
  <div id="ansCHK26" style="display:none; margin-top:.5rem">
    <ul>
      <li><strong>Attributi molto opzionali?</strong> → Valuta specializzazione.</li>
      <li><strong>Vincoli diversi tra sottoinsiemi?</strong> → Specializza e localizza i vincoli.</li>
      <li><strong>Relazioni diverse per sottoinsiemi?</strong> (es. solo Docente ha “Insegna”) → Specializza.</li>
      <li><strong>Query spesso filtrano per tipo?</strong> (es. “solo Studenti”) → Specializza per chiarezza ed efficienza concettuale.</li>
    </ul>
  </div>
</div>

<h2>Domanda-guida</h2>
<div class="box">
  <p><strong>Quando è preferibile introdurre una specializzazione invece di un unico tipo con attributi opzionali?</strong></p>
  <button id="btnDG26" onclick="toggleBox('btnDG26','ansDG26')">Mostra ▼</button>
  <div id="ansDG26" style="display:none; margin-top:.5rem">
    <ul>
      <li><strong>Regole diverse</strong>: se sottoinsiemi richiedono domini, obbligatorietà o vincoli propri (es. <code>Docente.PagaOraria ≥ 0</code> che non esiste per <code>Studente</code>), la specializzazione rende esplicite tali regole.</li>
      <li><strong>Relazioni esclusive</strong>: quando alcuni ruoli/relazioni valgono solo per un sottoinsieme (es. <code>Docente</code> partecipa a <em>Insegna</em>, <code>Studente</code> a <em>Iscritto</em>), i sottotipi separano correttamente le partecipazioni.</li>
      <li><strong>Identità uniforme</strong>: se l’identificatore è comune (chiave di <code>PERSONA</code>) ma i dati variano per ruolo, i sottotipi ereditano la stessa chiave e aggiungono attributi pertinenti.</li>
      <li><strong>Manutenibilità</strong>: riduce “campi-null-per-sempre”, evita validazioni condizionali complicate e semplifica la comprensione del modello.</li>
      <li><strong>Decisione pratica</strong>: se ≥2 di queste condizioni sono vere, <em>introduci la specializzazione</em>; altrimenti mantieni un solo tipo con pochi opzionali ben motivati.</li>
    </ul>

    <div class="ok" style="margin-top:.5rem">
      <strong>Esempio</strong>: <code>PERSONA</code> con attributi opzionali <em>Matricola</em> (solo studenti) e <em>Dipartimento</em> (solo docenti) e relazioni distinte → <strong>specializza</strong> in <code>STUDENTE</code> e <code>DOCENTE</code> (D, T).
    </div>
  </div>
</div>


      </div>
    </div>

    <div class="nav-buttons" style="margin-top:10px">
      <button onclick="prevSlide()">&#8592; Indietro</button>
      <button onclick="nextSlide()">Avanti &#8594;</button>
    </div>
  </div>
</body>
</html>
